<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>12. 데이터 시스템의 미래 - suffed-raid archive</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">suffed-raid archive</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <pre><code class="language-jsx">어플리케이션을 설계하고 구축하는 방법을 근본적으로 개선하는 아이디어와 접근법을 제시
이 책의 목적은 어플리케이션과 시스템을 신뢰할 수 있고 확장 가능하며 
유지보수하기 쉽게 만드는 방법을 탐구하는 것
</code></pre>
<h3 id="1-데이터-통합"><a class="header" href="#1-데이터-통합">1. 데이터 통합</a></h3>
<h3 id="11-파생-데이터에-특화된-도구의-결합"><a class="header" href="#11-파생-데이터에-특화된-도구의-결합">1.1 파생 데이터에 특화된 도구의 결합</a></h3>
<h3 id="111-데이터플로에-대한-추론"><a class="header" href="#111-데이터플로에-대한-추론">1.1.1 데이터플로에 대한 추론</a></h3>
<ul>
<li>같은 데이터의 사본을 여러 저장소 시스템에 유지해야 할 때 입력과 출력을 분명히 해야한다.</li>
<li>어디서 데이터를 처음으로 기록하는지, 어떤 표현형이 어떤 원본에서 파생되는지, 데이터를 모두 올바른 장소로 올바른 형식으로 어떻게 넣는지 등에 대해 충분히 고려해야 한다.</li>
<li>파생 데이터 시스템은 이벤트 로그를 기반으로 갱신하면 결정적이고 멱등성을 지녀 결함에서 복구하기가 상당히 쉬워진다.</li>
</ul>
<h3 id="112-파생-데이터-대-분산-트랜잭션"><a class="header" href="#112-파생-데이터-대-분산-트랜잭션">1.1.2 파생 데이터 대 분산 트랜잭션</a></h3>
<ul>
<li>파생 데이터와 분산 트랜잭션의 큰 차이점
<ul>
<li>트랜잭션 시스템은 일반적으로 선형성을 지원한다. (자신이 쓴 내용 읽기 같은 유용한 기능을 보장)</li>
<li>파생 데이터 시스템은 대개 비동기로 갱신되기 때문에 기본적으로 동시간 갱신 보장을 하지 않는다.</li>
</ul>
</li>
</ul>
<h3 id="113-전체-순서화의-제약"><a class="header" href="#113-전체-순서화의-제약">1.1.3 전체 순서화의 제약</a></h3>
<ul>
<li>작은 시스템에서 이벤트 로그의 순서 전체를 보장하는 것은 가능하나 규모가 커지면 한계가 생긴다.</li>
<li>이벤트 전체 순서를 결정하는 것은 <strong>전체 순서 브로드캐스트</strong> 라고 하고, 이것은 합의와 동등하다.</li>
</ul>
<h3 id="12-일괄-처리와-스트림-처리"><a class="header" href="#12-일괄-처리와-스트림-처리">1.2 일괄 처리와 스트림 처리</a></h3>
<ul>
<li>데이터 통합의 목표는 데이터를 올바른 장소에 올바른 형태로 두는 것</li>
<li>이것을 위해 입력을 소비해 적절한 출력으로 기록해야 한다.</li>
</ul>
<h3 id="121-파생-상태-유지"><a class="header" href="#121-파생-상태-유지">1.2.1 파생 상태 유지</a></h3>
<ul>
<li>일괄 처리는 결정적이고 출력이 입력에만 의존하며, 명시적 출력 외에는 다른 부수 효과가 없는 순수 함수를 장려한다.</li>
<li>입력과 출력을 잘 정의한 결정적 함수의 원리는 내결함성에 도움이 될 뿐만 아니라 조직 내의 데이터플로 추론을 단순화한다.</li>
<li>비동기 방식을 사용하면 이벤트 로그 기반 시스템을 훨씬 견고하게 만들 수 있다.</li>
<li>색인을 비동기 방식으로 유지한다면 파티션 간 통신에서 더욱 신뢰성 있고 확장성이 좋아진다.</li>
</ul>
<h3 id="122-애플리케이션-발전을-위한-데이터-재처리"><a class="header" href="#122-애플리케이션-발전을-위한-데이터-재처리">1.2.2 애플리케이션 발전을 위한 데이터 재처리</a></h3>
<ul>
<li>파생 데이터를 유지할 때 일괄 처리와 스트림 처리는 모두 유용하다.
<ul>
<li><strong>스트림</strong> 처리를 이용하면 입력의 변화를 <strong>빠르게</strong> 파생 뷰에 반영할 수 있다.</li>
<li><strong>일괄 처리 시스템</strong>을 사용하면 <strong>누적된 상당한 양</strong>의 과거 데이터를 재처리해 기존 데이터셋을 반영한 새 파생 뷰를 만들 수 있다.</li>
</ul>
</li>
<li>기존 데이터를 재처리하는 것은 시스템을 유지보수하기 위한 좋은 메커니즘으로 새로운 기능 추가와 변경된 요구사항에 대응할 수 있다.
<ul>
<li>재처리 없이 스키마를 변경하는 작업은 새 필드를 추가하는 것과 같은 간단한 것으로 제한된다.</li>
<li>반면 재처리를 이용하면 완전히 다른 모델로 데이터셋을 재구축할 수 있다.</li>
</ul>
</li>
<li>파생 뷰를 사용하면 <strong>점진적</strong> 발전이 가능하다.
<ul>
<li>이전 스키마와 새 스키마를 함께 유지해 같은 데이터를 기반으로 두 개의 독립적인 파생 뷰를 만들 수 있으며 점진적으로 새 뷰를 접근하는 비율을 늘려 기존 뷰를 내릴 수 있다.</li>
<li>점진적 이전의 장점은 처리의 모든 단계에서 뭔가 잘못됐을 때 쉽게 이전으로 되돌릴 수 있다는 점이다.</li>
</ul>
</li>
</ul>
<h3 id="2-데이터베이스-언번들링"><a class="header" href="#2-데이터베이스-언번들링">2 데이터베이스 언번들링</a></h3>
<h3 id="21-데이터-저장소-기술-구성하기"><a class="header" href="#21-데이터-저장소-기술-구성하기">2.1 데이터 저장소 기술 구성하기</a></h3>
<ul>
<li>데이터베이스에 내장된 기능과 일괄 처리와 스트림 처리로 구축하는 파생 데이터 시스템 사이에는 유사점이 있다.</li>
</ul>
<h3 id="211-색인-생성하기"><a class="header" href="#211-색인-생성하기">2.1.1 색인 생성하기</a></h3>
<ul>
<li>CREATE INDEX를 실행할 때마다 데이터베이스는 근본적으로 기존 데이터셋을 재처리해서 기존 데이터를 반영하는 새로운 뷰로서 색인을 파생하는데, 이것은 스트림 시스템에서 변경 데이터 캡처의 예비 과정과도 상당히 유사하다.</li>
</ul>
<h3 id="212-모든-것의-메타데이터베이스"><a class="header" href="#212-모든-것의-메타데이터베이스">2.1.2 모든 것의 메타데이터베이스</a></h3>
<ul>
<li>일종의 전체 조직의 데이터플로가 거대한 데이터베이스처럼 볼 수 있다.</li>
<li>일괄 처리와 스트림 처리자는 트리거와 스토어드 프로시저 그리고 구체화 뷰 유지 루틴을 정교하게 구현한 것과 같다.</li>
</ul>
<h3 id="22-데이터플로-주변-애플리케이션-설계"><a class="header" href="#22-데이터플로-주변-애플리케이션-설계">2.2 데이터플로 주변 애플리케이션 설계</a></h3>
<ul>
<li>현대 데이터 시스템은 내결함성과 확장성이 있어야 하고 지속성 있게 데이터를 저장해야 한다.</li>
<li>또한 데이터 시스템은 시간이 흐름에 따라 다른 그룹의 사람들이 개발한 이종 기술과도 통합이 가능해야 할 뿐 아니라 이미 존재하는 라이브러리와 서비스를 재사용 가능해야 한다.</li>
</ul>
<h3 id="221-파생-함수로서의-애플리케이션-코드"><a class="header" href="#221-파생-함수로서의-애플리케이션-코드">2.2.1 파생 함수로서의 애플리케이션 코드</a></h3>
<ul>
<li>데이터셋이 다른 데이터셋으로부터 파생될 때는 변환 함수 몇가지를 거친다.</li>
<li>보조 색인용 파생 함수는 아주 일반적인 요구사항이라서 많은 데이터베이스에 핵심 기능으로 내장돼 있다.</li>
<li>파생 데이터셋을 생성하는 함수가 보조 색인 생성 함수와 같은 비슷한 표준 함수가 아니라면 사용자 정의 코드를 써서 애플리케이션에 특화된 측면을 다뤄야 한다.</li>
</ul>
<h3 id="222-애플리케이션-코드와-상태의-분리"><a class="header" href="#222-애플리케이션-코드와-상태의-분리">2.2.2 애플리케이션 코드와 상태의 분리</a></h3>
<ul>
<li>이론상 데이터베이스가 운영체제와 같이 임의의 애플리케이션 코드를 배포하는 환경이 될 수 있으나 이는 현실성이 부족하다.</li>
<li>메소스, 얀, 도커, 쿠버네티스 등과 같은 배포와 클러스터 관리 도구는 애플리케이션 코드를 수행하는 목적으로 특별히 설계되었다.</li>
<li>오늘날 대부분의 웹 애플리케이션은 상태 비저장 서비스로 배포된다.
<ul>
<li>상태 비저장 서비스 내에서 사용자 요청은 어떤 애플리케이션 서버로도 라우트될 수 있다.</li>
<li>상태 관리(데이터베이스)와 상태 비저장 애플리케이션 로직을 분리한다.</li>
</ul>
</li>
<li>전형적인 웹 애플리케이션 데이터베이스는 네트워크를 통해 동기식으로 접근할 수 있는 변경 가능한 공유 변수와 같이 동작한다.
<ul>
<li>애플리케이션은 이 변수를 읽고 갱신할 수 있으며 데이터베이스는 이 변수를 지속성 있게 만들고 동시성 제어와 내결함성을 지원한다.</li>
</ul>
</li>
<li>대부분의 프로그래밍 언어에서 변경 가능한 변수의 변경을 구독할 수 없다.</li>
<li>데이터베이스의 내용이 변경됐는지 확인하고 싶다면 폴링, 즉 주기적으로 질의를 반복하는 게 유일한 방법이다.</li>
</ul>
<h3 id="223-스트림-처리자와-서비스"><a class="header" href="#223-스트림-처리자와-서비스">2.2.3 스트림 처리자와 서비스</a></h3>
<ul>
<li>단일 일체식 애플리케이션에 비해 서비스 지향 아키텍처의 가장 큰 장점은 느슨한 연결을 통한 조직적 확장성이다.</li>
<li>서로 다른 팀은 다른 서비스를 운영하기에, 서비스가 독립적으로 배포되고 갱신될 수 있다.</li>
<li>스트림 연산자로 데이터플로 시스템을 구성하는 것은 마이크로서비스 접근법과 유사한 특징이 상당히 많지만 기반이 되는 통신 메커니즘은 매우 다르다.
<ul>
<li>마이크로서비스는 동기식 요청/응답</li>
<li>스트림 연산자 시스템은 단방향 비동기식 메시지 스트림</li>
</ul>
</li>
</ul>
<h3 id="23-파생-상태-관찰하기"><a class="header" href="#23-파생-상태-관찰하기">2.3 파생 상태 관찰하기</a></h3>
<ul>
<li>데이터플로 시스템은 검색 색인이나 구체화 뷰 또는 예측 모델과 같은 파생 데이터셋을 생성하고 최신 상태로 유지하는 과정에 사용할 수 있다.</li>
<li>시스템에 정보를 기록할 때마다 일괄 처리와 스트림 처리의 여러 단계를 거친 다음 결과적으로 기록된 데이터를 모든 파생 데이터셋에 통합해 갱신한다.</li>
<li>파생 데이터를 생성하는 이유는 이후에 같은 질의를 할 가능성이 크기 때문이다.</li>
<li>파생 데이터셋은 쓰기와 읽기가 만나는 장소로, 쓰기 시간에 필요한 작업의 양과 읽기 시간에 필요한 작업의 양 간에 트레이드 오프를 나타낸다.</li>
</ul>
<h3 id="231-구체화-뷰와-캐싱"><a class="header" href="#231-구체화-뷰와-캐싱">2.3.1 구체화 뷰와 캐싱</a></h3>
<ul>
<li>전문 검색 색인은 좋은 예제로, 키워드에서 모든 단어를 포함(AND)하거나 어떤것이든 포함(OR)하는 등의 논리를 적용해야 한다.</li>
<li>색인이 존재하지 않는다면 검색 질의는 모든 문서를 스캔해야 한다.</li>
<li>색인이 없으면 쓰기 경로의 작업량은 줄지만 읽기 경로의 작업이 상당히 늘어난다.</li>
<li>고정된 가장 공통적인 질의 집합의 검색 결과를 미리 계산 해 색인까지 가지 않고 빠르게 처리 할 수 있다. 이를 일반적으로 공통 질의 <strong>캐시</strong>라고 한다.</li>
</ul>
<h3 id="232-오프라인-대응-가능한-상태-저장-클라이언트"><a class="header" href="#232-오프라인-대응-가능한-상태-저장-클라이언트">2.3.2 오프라인 대응 가능한 상태 저장 클라이언트</a></h3>
<ul>
<li><strong>오프라인 우선 애플리케이션</strong>은 인터넷 연결 요구 없이 같은 장치의 로컬 데이터베이스를 이용해 최대한 많은 일을 하고, 네트워크 연결이 가능할 때 백그라운드에서 원격 서버와 동기화 한다.</li>
<li>장치 상 상태를 <strong>서버 상 상태의 캐시</strong>로 생각할 수 있다.</li>
</ul>
<h3 id="233-상태-변경을-클라이언트에게-푸시하기"><a class="header" href="#233-상태-변경을-클라이언트에게-푸시하기">2.3.3 상태 변경을 클라이언트에게 푸시하기</a></h3>
<ul>
<li>명시적으로 변경 사항을 폴링하지 않으면 장치의 상태는 갱신되지 않은 신선도가 떨어지는 캐시다.</li>
<li>많은 최신 프로토콜이 HTTP의 기본적인 요청/응답 패턴을 벗어나고 있다.
<ul>
<li>서버 전송 이벤트(이벤트 소스, Event Source API)와 웹소켓(WebSocket) 은 웹브라우저가 서버와 TCP 접속을 유지하면서 연결이 유지되는 동안 서버가 주도적으로 메시지를 브라우저에 보내는 방식의 통신 채널을 제공한다.</li>
<li>이 방식을 통해 서버의 로컬에 저장된 상태가 변경되었을 때 서버에서 주도적으로 사용자에게 알려줘, 클라이언트 측 상태의 신선도가 떨어지는 것을 줄여준다.</li>
</ul>
</li>
<li>로그 기반 메시지 브로커를 통해도 오프라인 장치에 대한 알림을 날려줄 수 있다.</li>
</ul>
<h3 id="234-종단-간-이벤트-스트림"><a class="header" href="#234-종단-간-이벤트-스트림">2.3.4 종단 간 이벤트 스트림</a></h3>
<ul>
<li>상태 저장 클라이언트와 사용자 인터페이스 개발용 최신 도구는 이미 내부적으로 사용자 입력을 표현하는 <strong>이벤트 스트림</strong>이나 <strong>서버 응답 스트림을 구독</strong>하는 방식을 사용해 클라이언트 측 상태를 관리한다.</li>
<li>상태 변경은 종단 간(end-to-end) 쓰기 경로를 따라 흐를 수 있다.
<ul>
<li>즉, 상태 변경이 트리거된 한 장치로부터 다른 장치의 상태를 보고 있는 사람의 사용자 인터페이스까지 이어진다.</li>
</ul>
</li>
<li>다만 쓰기 경로를 최종 사용자까지 확장하려면 근본적으로 시스템을 구축하는 방식을 재고할 필요가 있다.
<ul>
<li>요청/응답 상호작용 방식에서 벗어나 발행/구독 데이터플로 방식으로 변경해야 한다.</li>
<li>데이터 시스템을 설계한다면 현재 상태를 단지 질의하는 방식이 아니라 변경 사항을 구독하는 방식을 염두에 두어야 한다.</li>
</ul>
</li>
</ul>
<h3 id="235-읽기도-이벤트다"><a class="header" href="#235-읽기도-이벤트다">2.3.5 읽기도 이벤트다</a></h3>
<ul>
<li>일회성 읽기 요청은 단지 조인 연산자를 통해 흘러가고 이후 즉시 사라진다.</li>
<li>그러나 읽기 이벤트 로그를 기록하면 잠재적으로 인과적 의존성과 시스템 전체의 데이터 출처를 추적할 수 있다는 장점이 있다.</li>
<li>지속성 있는 저장소에 읽기 이벤트를 기록하면 인과적 의존성을 추적하기가 더 용이하나,추가 저장소가 필요하며 I/O 비용이 발생한다.</li>
</ul>
<h3 id="3-정확성을-목표로"><a class="header" href="#3-정확성을-목표로">3. 정확성을 목표로</a></h3>
<h3 id="31-데이터베이스에-관한-종단-간-논증"><a class="header" href="#31-데이터베이스에-관한-종단-간-논증">3.1 데이터베이스에 관한 종단 간 논증</a></h3>
<ul>
<li>직렬성 트랜잭션 같은 비교적 강력한 안전성 속성을 지원하는 데이터 시스템을 사용해도 애플리케이션에 데이터 유실과 손상이 없을 것이라는 보장은 없다.</li>
</ul>
<h3 id="311-연산자의-정확히-한-번-실행"><a class="header" href="#311-연산자의-정확히-한-번-실행">3.1.1 연산자의 정확히 한 번 실행</a></h3>
<ul>
<li>실패한다면 포기하거나 재시도하며, 재시도는 중복의 위험성이 있다.</li>
<li>정확히 한 번 연산은 재시도시 동일한 결과를 최종적으로 얻기 위해 계산을 조정한다는 뜻이다.</li>
<li>가장 효과적인 접근법 중 하나는 연산은 <strong>멱등</strong>으로 만드는 것이다.</li>
</ul>
<h3 id="312-연산-식별자"><a class="header" href="#312-연산-식별자">3.1.2 연산 식별자</a></h3>
<ul>
<li>고유 ID를 사용해 중복 요청을 억제할 수 있다.</li>
<li>고유 식별자를 만들어 클라이언트 애플리케이션 내 숨은 폼 필드에 포함하거나 유효한 모든 폼 필드의 해시값을 계산해서 연산 ID를 만들 수 있다.</li>
</ul>
<h3 id="32-제약-조건-강제하기"><a class="header" href="#32-제약-조건-강제하기">3.2 제약 조건 강제하기</a></h3>
<h3 id="321-유일성-제약-조건은-합의가-필요하다"><a class="header" href="#321-유일성-제약-조건은-합의가-필요하다">3.2.1 유일성 제약 조건은 합의가 필요하다</a></h3>
<ul>
<li>유일성 제약 조건을 강제하기 위해서는 합의가 필요하다.</li>
<li>합의를 달성하는 가장 일반적인 방법은 단일 노드를 리더로 만들고 해당 노드가 모든 결정을 하게끔 책임을 부여하는 것이다.</li>
<li>유일성 검사는 유일성이 필요한 값을 기준으로 파티셔닝하면 확장 가능하다.</li>
<li>비동기 마스터 복제는 충돌되는 쓰기를 받아들여 값이 유일하지 않을 수 있기 때문에 쓸 수 없다.</li>
<li>제약 조건을 위반하면 어떤 쓰기도 즉시 거부하기를 원한다면 <strong>동기식 코디네이션</strong>이 필요하다.</li>
</ul>
<h3 id="322-로그-기반-메시징의-유일성"><a class="header" href="#322-로그-기반-메시징의-유일성">3.2.2 로그 기반 메시징의 유일성</a></h3>
<ul>
<li>로그는 모든 소비자가 동일한 순서로 메시지를 보도록 보장한다.</li>
<li>공식적으로 이 보장을 <strong>전체 순서 브로드캐스트(total order broadcast)</strong> 라 부르고 이것은 합의와 동일하다.</li>
<li>스트림 처리자는 단일 스레드 상에서 한 로그 파티션의 모든 메시지를 순차적으로 소비한다.</li>
<li>유일성 기준으로 로그를 파티셔닝하면 스트림 처리자는 충돌이 발생한 연산 중 어떤 것이 처음 들어온 연산인지 판단할 수 있다.</li>
<li>파티션 수를 늘리면 쉽게 확장할 수 있어 대규모 요청을 처리할 수 있다.</li>
<li>근본 원리는 충돌이 발생할 수 있는 쓰기를 모두 같은 파티션으로 라우팅하고 순서대로 처리하는 것으로, 유일성 제약 조건뿐만 아니라 다른 많은 제약 조건에도 사용할 수 있다.</li>
</ul>
<h3 id="33-적시성과-무결성"><a class="header" href="#33-적시성과-무결성">3.3 적시성과 무결성</a></h3>
<ul>
<li>트랜잭션의 한 가지 편리한 속성은 대개 선형성이 있다는 점입니다.
<ul>
<li>즉, 기록자는 트랜잭션이 커밋될 때까지 기다리고 커밋 이후부터 해당 쓰기가 모든 독자에게 보인다.</li>
</ul>
</li>
<li>일반적으로, <strong>일관성</strong>이라는 용어는 두 가지 요구사항이 합쳐진 것을 볼 수 있다.
<ul>
<li><strong>적시성(Timeliness)</strong> : 사용자가 시스템을 항상 최신 상태로 관측 가능</li>
<li><strong>무결성(Integrity)</strong> : 손상이 없음</li>
</ul>
</li>
<li>적시성 위반은 "최종적 일관성"이고 무결성 위반은 "영구적 불일치" 로 볼 수 있다.</li>
<li>적시성을 위반하면 성가시고 혼란스러울 수 있으나, 무결성을 위반하면 파국을 맞는다.</li>
</ul>
<h3 id="331-데이터플로-시스템의-정확성"><a class="header" href="#331-데이터플로-시스템의-정확성">3.3.1 데이터플로 시스템의 정확성</a></h3>
<ul>
<li><strong>ACID 트랜잭션</strong>은 대개 적시성과 무결성 양쪽 모두 보장하므로 적시성과 무결성을 구분하는 것은 중요하지 않다.</li>
<li>반면 <strong>이벤트 기반 데이터플로 시스템</strong>은 적시성과 무결성을 분리한다. 무결성이 스트림 시스템의 핵심</li>
<li>신뢰성 있는 스트림 처리 시스템은 분산 트랜잭션과 원자적 커밋 프로토콜 없이 무결성을 보존할 수 있다.</li>
<li>무결성은 아래 메커니즘의 결합을 통해 달성할 수 있다.
<ul>
<li>쓰기 연산을 단일 메시지로 표현하기</li>
<li>결정적 파생 함수를 사용해 해당 단일 메시지에서 모든 상태 갱신을 파생하기</li>
<li>클라이언트가 생성한 요청 ID를 모든 처리 단계를 통해 전달하기</li>
<li>메시지를 불변으로 만들고 필요 시 파생 데이터 재처리하기</li>
</ul>
</li>
</ul>
<h3 id="332-느슨하게-해석되는-제약-조건"><a class="header" href="#332-느슨하게-해석되는-제약-조건">3.3.2 느슨하게 해석되는 제약 조건</a></h3>
<ul>
<li>유일성 제약 조건을 강제하려면 합의가 필요하고 합의는 일반적으로 모든 이벤트를 단일 노드를 통해 특정 파티션으로 보내 처리하는 방식으로 구현된다.</li>
<li>많은 애플리케이션이 훨씬 완화된 유일성 개념을 사용해 이 제한을 피할 수 있다.
<ul>
<li>두 사람이 동시에 같은 사용자명을 등록하거나 같으 좌석을 예약한다면, 두 사람 중 한 사람에게 사과 메시지를 보내 다른 이름이나 좌석을 고르게끔 부탁할 수 있다. 이러한 종류의 변경 방법을 <strong>보상 트랜잭션</strong>이라고 한다.</li>
<li>소비자가 재고보다 더 많은 상품을 주문한다면 일단 재고 주문을 더 넣고 소비자에게 배송 지연에 대해 사과하고 가격을 할인해준다.</li>
<li>비슷하게 많은 항공사가 일부 승객이 비행기를 놓칠 것으로 예상하고 초과 예약을 받는다.</li>
<li>누군가 계좌 잔고보다 더 많은 돈을 뺀다면 은행은 그 사람에게 초과 인출 수수료를 부과하고 빚진 돈을 값으라고 요구한다.</li>
</ul>
</li>
<li>많은 비즈니스 맥락에서 제약 조건을 일시적으로 위반하고 나중에 사과해 바로잡는 것은 실제로 수용 가능한 방법이다.</li>
<li>애플리케이션은 <strong>무결성을 반드시 요구</strong>한다. 그러나 제약 조건을 강제하는 상황에서도 적시성은 <strong>반드시</strong> 필요한 것은 아니다.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../data/10. 일괄 처리.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../elastic/엘라스틱_스택이란.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../data/10. 일괄 처리.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../elastic/엘라스틱_스택이란.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
