
# Part 3. 파생 데이터

1, 2부에서는 애플리케이션이 단일 데이터베이스를 사용한다고 가정했으나 대부분의 애플리케이션은 여러 다른 데이터스토어, 색인, 캐시, 분석 시스템 등 몇 가지를 조합해서 사용하고 한 저장소에서 다른 저장소로 데이터를 이동하는 매커니즘을 구현한다.

#### 데이터를 저장하고 처리하는 시스템
##### 레코드 시스템
믿을 수 있는 데이터 버전을 저장한다. 진실의 근원. 사용자 입력과 같은 새로운 데이터가 들어오면 먼저 레코드 시스템에 저장한다.

##### 파생 데이터 시스템
다른 시스템에 존재하는 데이터를 가져와 특정 방식으로 변환하고 처리한 결과. 파생 데이터를 잃게 되더라도 원천 데이터로부터 다시 생성할 수 있다. 대표적인 예가 캐시
기존 데이터를 복제한다는 의미에서 중복이라고 할 수 있지만 읽기 질의 성능을 높이는 데 필수적이다.

# 10장. 일괄 처리

#### 시스템 유형

##### 서비스 (온라인 시스템)
서비스는 클라이언트로부터 요청이나 지시가 올 때까지 기다린다. 요청이 들어오면 서비스는 가능한 빨리 처리해서 응답을 보내려한다. **응답시간**은 서비스 성능의 중요한 지표이다.

##### 일괄 처리 시스템 (오프라인 시스템)
매우 큰 입력 데이터를 받아서 데이터를 처리하는 작업을 수행하고 결과 데이터를 생산한다. 수 분에서 수 일이 걸리기 때문에 사용자가 대기하지 않는다. **처리량**이 주요 성능 지표이다.
신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션을 구축하는 데 매우 중요한 구성요소.

##### 스트림 처리 시스템 (준실시간 시스템)
스트림 처리는 온라인과 오프라인/일괄 처리 사이의 어딘가에 있기 때문에 때로 준실시간 처리라 불린다. 일괄 처리 시스템과 마찬가지로 요청에 대해 응답하지 않으며 입력 데이터를 소비하고 출력 데이터를 생산한다. 
그러나 일괄 처리 시스템은 정해진 크기의 입력 데이터를 대상으로 하는데 반해 스트림 처리는 **입력 이벤트**가 발생한 직후 바로 작동한다. 따라서 일괄 처리 시스템보다 지연 시간이 낮다.


### 유닉스 철학

유닉스의 자동화, 빠른 프로토타이핑, 증분 반복, 실험 친화, 큰 프로젝트를 청크로 나누어 처리하기 등의 방법은 오늘날의 애자일 및 DevOps 운동과 매우 흡사하다. 유닉스의 설계 철학은 맵리듀스 및 최근에 개발된 데이터플로 엔진에 녹아 있다.

#### 인터페이스

- 특정 프로그램이 다른 어떤 프로그램과도 연결 가능하려면 프로그램 모두가 같은 입출력 인터페이스를 사용해야 한다.
- 유닉스에서의 인퍼테이스는 파일
- 수십 년이 지났어도 유닉스 도구만큼 상호 운용 또는 구성 면에서 뛰어난 소프트웨어는 많지 않다.
- 데이터베이스 간에도 한쪽에서 다른 쪽으로 데이터를 옮기는 게 쉽지 않다.
- 데이터는 유닉스 도구와 같은 통합이 부족해서 발칸화 되었다.

#### 로직과 연결의 분리

- 표준 입력 `stdin`과 표준 입력 `stdout`을 사용
- 셸 사용자는 유닉스 접근법으로 원하는 대로 입력과 출력을 연결할 수 있다.

#### 투명성과 실험

- 유닉스 도구는 진행 사항을 파악하기가 상당히 쉽다.
- 유닉스 명령에 들어가는 입력 파일은 일반적으로 불변으로 처리된다. 얼만큼 명령을 수행하더라도 입력 파일에는 손상을 주지 않는다.
- 어느 시점이든 파이프라인을 중단하고 출력을 해 볼 수 있기 때문에 디버깅에 유용하다.
- 특정 파이프라인 단계의 출력을 파일에 쓰고 그 파을을 다음 단계의 입력으로 사용할 수 있다.
- 전체 파이프라인을 다시 시작하는게 아니라 다음 단계부터만 재시작 가능하다.

유닉스 도구는 이와 같이 유용하지만 단일 장비에서만 실행이 가능하다. 이러한 점때문에 하둡과 같은 도구가 필요하다.

## 맵리듀스와 분산 파일 시스템

### 맵리듀스

- 하나 이상의 입력을 받아 하나 이상의 출력을 만들어 낸다는 점에서 유닉스 프로세스와 비슷하다.
- 그러나 맵리듀스는 수천 대의 장비로 분산해서 실행이 가능하다는 점에서 차이가 있다.
- 분산 파일 시스템상의 파일을 입력과 출력으로 사용

##### HDFS (Hadoop Distributed File System)
하둡 맵리듀스 구현 시스템으로, GFS(Google File System)을 재구현한 오픈소스이다. 비공유 원칙을 기반으로 하며 각 장비에서 다른 노드에 저장된 파일에 접근 가능한 데몬 프로세스로 구성된다. HDFS는 매우 큰 하나의 파일 시스템이고 데몬이 실행 중인 모든 장비의 디스크를 사용할 수 있다.
또한 HDFS는 확장성이 뛰어나고 수만 대의 장비를 묶어서 실행 할 수 있다. 오픈소스이기 때문에 다른 전용 저장소 장치를 사용하는 비용보다 훨씬 저렴하고 대규모 확장이 가능하다.

##### 맵리듀스 작업
맵리듀스 작업은 4가지 단계로 수행한다. 2단계(맵)과 4단계(리듀스)는 사용자가 직접 작성한 데이터 처리 코드이고 1단계는 파일을 나누어 레코드를 만드는 데 입력 형식 파서를 사용한다. 
대부분 맵리듀스 작업 하나의 출력을 다른 맵리듀스 작업의 입력으로 사용하는 워크플로를 사용한다. 추천 시스템을 구축하는 데 사용하는 워크플로는 50개에서 100개가 일반적이다.

1. 입력 파일을 읽고 레코드로 쪼갠다.
2. 각 입력 레코드마다 매퍼 함수를 호출해 키와 값을 추출한다. 
3. 키를 기준으로 키-값 쌍을 모두 정렬한다.
4. 정렬된 키-값 쌍 전체를 대상으로 리듀스 함수를 호출한다.

##### 매퍼
모든 입력 레코드마다 한 번씩만 호출된다. 입력 레코드로부터 키와 값을 추출한다. 각 레코드를 독립적으로 처리한다.

##### 리듀서
매퍼가 생산한 키-값 쌍을 받아 같은 키를 가진 레코드를 모우고 해당 값의 집합을 반복해 리듀서 함수를 호출한다.

### 분산 일괄 처리

#### 파티셔닝
맵리듀스 매퍼는 입력 파일 블록에 따라 파티셔닝된다. 매퍼의 출력은 재파티셔닝해 정렬하고 리듀서 파티션으로 병합한다. 이 과정의 목적은 관련된 모든 데이터를 같은 장소로 가져오는 것이다.

#### 내결함성
맵리듀스는 데이터를 빈번히 디스크에 기록한다. 디스크에 기록하면 개별 테스크가 실패하더라도 전체 작업을 재수행하지 않고 쉽게 복구 할 수 있다. 하지만 작업이 실패하지 않는 경우 수행 시간이 느려지는 것은 감수해야한다. 데이터 플로 엔진은 중간 상태를 구체화하지 않고 대신 메모리에 상태를 유지한다. 
데이터 플로 엔진에서 내결함성을 확보하기 위해서는 실패한 연산자를 재실행 하더라도 결과가 동일하도록 연산자를 결정적으로 만드는 것이 좋다.


#### 조인 알고리즘
데이터베이스는 일반적으로 색인을 사용해서 관심 있는 레코드의 위치를 찾는다. 하지만 맵리듀스는 일반적으로 이야기하는 색인 개념이 없다. 맵리듀스 작업은 전체 내용을 읽는 **전체 테이블 스캔 full table scan**을 사용한다. 이런 작업은 대량의 레코드를 대상으로 집계를 할 때 유용하다. 

##### 정렬 병합 조인
조인할 각 입력은 조인 키를 추출하는 매퍼를 통과한다. 파티셔닝, 정렬, 병합 과정을 마치면 같은 키를 가지는 모든 레코드는 하나의 리듀서에서 호출된다. 이 리듀서 함수에서 병합된 레코드를 출력할 수 있다.

##### 브로드캐스트 해시 조인
조인할 입력 두 개 중 하나가 상대적으로 작다면 파티셔닝하지 않고 해시 테이블에 모두 적재할 수 있다. 큰 조인 입력의 각 파티션에서 매퍼를 시작할 때 각 매퍼에 작은 입력으로 만들어진 해시 테이블을 적재하고 큰 입력에서 한 번에 하나씩 레코드를 스캔하면서 각 레코드가 해시 테이블에 존재하는지 질의한다.

##### 파티션 해시 조인
조인 입력 두 개를 같은 방식으로 파티셔닝하면 해시 테이블 방식을 각 파티션별로 독립적으로 사용할 수 있다.


### 맵리듀스를 넘어

맵리듀스를 직접 사용하는 일은 어렵기 때문에 맵리듀스 상에서 추상화된 다양한 고수준 프로그래밍 모델이 등장했다. 이런 고수준 프로그래밍 모델은 맵리듀스가 어떻게 동작하는지 이해하고 있으면 배우기 쉽고 일반적인 일괄 처리 태스크를 구현하기에 상당히 편하다. 

#### 중간 상태
대개 한 작업의 출력은 같은 팀 내에서 유지보수하는 다른 특정 작업의 입력으로만 사용된다. 이 경우, 분산 파일 시스템 상에 있는 파일들은 단순히 한 작업에서 다른 작업으로 데이터를 옮기는 수단, 즉 **중간 상태**이다. 추천 시스템을 구축할 때 워크플로가 50개에서 100개가 된다면 여기에는 수 많은 중간 상태가 존재한다.

중간 상태를 파일로 기록하는 과정을 **구체화**라 한다. 중간 상태를 완전히 구체화하는 맵리듀스 접근법은 유닉스 파이프에 비해 여러 단점이 있다. 
- 모든 선행 작업이 완료됐을 때만 시작 가능하다. 워크플로 전체 수행 시간은 느려진다.
- 매퍼는 종종 중복되기도 한다.
- 중간 상태를 저장하는 것은 중간 상태 파일들이 여러 장비에 걸쳐 복제되었다는 의미로 과한 임시 데이터가 된다. 

#### 데이터플로 엔진
맵리듀스에 있는 이러한 문제를 해결하기 위해 분산 일괄 처리 연산을 수행하는 엔진이 새롭게 몇 가지 개발됐다. 이 엔진은 전체 워크플로를 독립된 하위 작업으로 나누지 않고 작업 하나로서 다룬다.
데이터플로 엔진은 단일 스레드에서 사용자 정의 함수를 반복 호출해 한번에 레코드 한 개씩 처리한다. 그리고 한 함수의 출력을 다른 함수의 입력으로 사용하기 위해 네트워크를 통해 복사한다.

맵리듀스와 달리 이 함수들은 맵과 리듀스를 번갈아 수행하는 식의 규칙을 엄격하게 지킬 필요가 없고 훨씬 유연한 방법으로 **함수(연산자)** 들을 조합할 수 있다. 

- 정렬과 같은 값비싼 작업은 실제로 필요할 때만 수행한다.
- 필요없는 맵 태스크는 없다.
- 워크플로에 조인과 데이터 의존 관계를 명시해서 스케줄러가 어느 데이터가 어디에 필요한지에 대한 개요를 가질 수 있게 한다.
- 연산자 간 중간 상태는 메모리나 로컬 디스크에 기록한다.
- 연산자들은 입력이 준비되는 즉시 실행을 시작할 수 있다.
- 새로운 연산자를 실행할 때 이미 존재하는 자바 가상 머신을 재활용할 수 있다.
- 위와 같은 최적화로 인해 수행 속도가 훨씬 빠르다.
