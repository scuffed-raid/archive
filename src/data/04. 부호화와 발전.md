애플리케이션은 필연적으로 시간이 지남에 따라 변하기 때문에 변경 사항을 쉽게 적용할 수 있게 시스템을 구축해야한다. 대부분의 경우, 기능을 변경하려면 저장하는 데이터도 변경이 필요하다.

많은 서비스가 한 번에 모든 노드에 배포하는 것보다 순회식 업그레이드가 필요하다. 따라서 시스템을 흐르는 모든 데이터는 하위 호환성과 상위 호환성을 제공하는 방식으로 부호화해야 한다.

- 하위 호환성: 새로운 코드가 예전 데이터를 읽을 수 있음
- 상위 호환성: 예전 코드가 새로운 데이터를 읽을 수 있음

## 데이터 부호화 형식

데이터를 파일에 쓰거나 네트워크를 통해 전송하려면 스스로를 포함한 일련의 바이트열의 형태로 부호화해야한다. 부호화는 데이터 구조를 네트워크나 디스크 상의 바이트열로 변환하는 다양한 방법으로, 애플리케이션의 아키텍처와 배포의 선택 사항에도 영향을 미친다.

- 부호화: 인메모리 표현에서 바이트열로의 전환, 직렬화나 마샬링이라고도 한다.
- 복호화: 부호화의 반대 표현, 파싱, 역직렬화, 언마샬링이라고도 부른다.


### 언어별 형식

자바의 `Serializable`, 루비의 `Marshal`, 파이썬의 `pickle` 등 프로그래밍 언어에는 인메모리 객체를 바이트열로 부호화하는 기능을 내장한다. 

#### 문제점

- 다른 언어에서 데이터를 읽기 힘들기 때문에 통합을 방해한다.
- 복호화 과정이 임의의 클래스를 인스턴스화하는 것이기 때문에 보안 문제가 되기도 한다.
- 쉬운 부호화를 우선시하다 상하위 호환성의 불편한 문제가 등한시 되는 경우가 있다.

### JSON과 XML, 이진 변형

많은 프로그래밍 언어에서 읽고 쓸 수 있는 표준화된 부호화. JSON, XML, CSV는 텍스트 형식이기 때문에 사람이 읽을 수도 있다. 선택적 스키마 언어가 있어 때로는 유용하지만 때로는 방해된다. 이 형식들은 데이터 타입에 대해 다소 모호한 점이 있기 때문에 숫자나 이진 문자열과 같은 항목은 주의가 필요하다.

#### 문제점

- XML과 CSV는 숫자와 수로 구성된 문자열을 구분할 수 없다. JSON은 구별할 수는 있지만 정수와 부동소수점 수를 구별하지 않고 정밀도를 지정하지 않는다.
- 큰 수를 다룰 때 문제가 된다.
- 유니코드 문자열은 지원하지만 이진 문자열을 지원하지 않는다. 
- XML과 JSON 모두 스키마를 지원하지만 구현하기가 난해하다.
- CSV는 스키마가 없다.

### 이진 부호화

조직 내에서만 사용하는 데이터라면 공통 분모를 찾는 부담감이 덜하기 때문에 조금 더 간편하고 파싱이 빠른 형식을 선택할 수 있다. 데이터셋이 테라바이트 정도가 되면 데이터 타입 선택이 큰 영향을 미치기 때문이다.

JSON, XML은 이진 형식에 비해 훨씬 많은 공간을 사용한다. 이는 다양한 이진 부호화의 개발로 이어졌다.

#### 이진 부호화의 종류
스리프트와 프로토콜 버퍼는 동일한 원리를 사용하며, 프로그래밍 코드로부터 생성되고 이를 의존한다. 또한 스키마를 변경할 때 매핑을 수동으로 갱신해야 한다. 그러므로 정적 타입 언어에 유용하다. 아브로는 동적 생성 스키마를 고려하여 개발되었으므로 스키마 변경을 간단하게 수행할 수 있다. 

1. 스리프트
2. 프로토콜 버퍼
3. 아브로

스리프트, 프로토콜 버퍼, 아브로같은 이진 스키마 기반 형식은 짧은 길이로 부호화가 가능하며 명확하게 정의된 상위 호환성과 하위 호환성의 맥락에서 효율적이다. 이러한 스키마는 정적 타입 언어에서 문서와 코드 생성에 유용하지만 사람이 읽으려면 복호화가 필요하다는 단점이 있다.

##### 쓰기 스키마
데이터를 전송할 때 부호화를 위해 애플리케이션에 포함하는 스키마

##### 읽기 스키마
어떤 데이터를 복호화할 때 의존하는 특정 스키마

## 데이터플로 모드

데이터플로는 매우 추상적인 개념으로, 하나의 프로세스에서 다른 프로세스로 데이터를 전달하는 방법을 말한다. 누가 데이터를 부호화하고 누가 복호화 하는가?

### 1. 데이터베이스

데이터 베이스에 기록하는 프로세스가 부호화하고 데이터베이스에서 읽는 프로세스가 복호화

### 2. REST와 RPC 서비스

클라이언트가 요청을 부호화하고 서버는 요청을 복호화해서 응답을 부호화하고 최종적으로 클라이언트가 응답을 복호화

- 서비스 지향 설계, 마이크로서비스 설계를 지향하면서 중요성이 대두
- 미리 정해진 입력과 출력만 허용한 애플리케이션 특화 API
- 서비스를 배포와 변경에 독립적으로 만들어 애플리케이션 변경과 유지보수를 더 쉽게 하는 것
- 서버와 클라이언트가 사용하는 데이터 부호화는 서비스 API의 버전 간 호환이 가능해야 한다.

#### REST
프로토콜이 아니라 HTTP의 원칙을 토대로 한 설계 철학. 실험과 디버깅에 적합하고 모든 주요 프로그래밍 언어와 플랫폼이 지원한다. 다양한 생태계가 구성되어 있다. URL이나 HTTP Accept 헤더에 버전 번호를 사용하는 방식이 일반적이다.

#### RPC
원격 프로시저 호출(remote procedure call, RPC) 모델은 원격 네트워크 서비스 요청을 같은 프로세스 안에서 특정 프로그래밍 언어의 함수나 메서드를 호출하는 것과 동일하게 사용 가능하게 해준다. 이를 위치 투명성이라 한다.

##### 결함
- 로컬 함수 호출은 예측이 가능한 반면 네트워크 요청은 예측이 어렵다
- 네트워크 문제로 요청이나 응답이 유실되거나 느려지거나 아예 응답을 하지 않을 수도 있다.
- 네트워크 문제는 일상적이며 제어할 수 없다.
- 실제로는 처리되고 응답만 유실될 수 있다 (멱등성 문제)

이런 문제를 해결하기 위해 차세대 RPC 프레임워크는 비동기 작업을 캡슐화하거나 시간에 따른 일련의 요청과 응답으로 구성된 스트림을 제공하기도 한다. 


### 3. 메세지

- 송신자가 부호화하고 수신자가 복호화하는 메시지를 서로 전송해서 노드 간 통신
- 클라이언트 요청(메시지)을 낮은 지연 시간으로 다른 프로세스에 전달한다는 점에서는 RPC와 비슷하나, 메세지를 직접 전송하지 않고 임시로 메시지를 저장하는 메시지 브로커 또는 큐, 미들웨어 라는 중간 단계를 거친다는 점은 데이터 베이스와 유사하다.
- 특정 데이터 모델을 강요하지 않으므로 유연성을 가진다.

#### 장점
- 수신자에 장애가 있을 때 메시지 브로커가 버퍼처럼 동작할 수 있으므로 시스템 안정성이 향상됨
- 죽었던 프로세스에 메시지를 다시 전송할 수 있어 유실이 방지됨
- 송신자가 수신자의  IP주소와 포트 번호를 알 필요가 없음
- 하나의 메시지를 여러 수신자로 전송할 수 있다.
- 송신자와 수신자가 논리적으로 분리된다.


## 결론

주의를 기울이면 ==상하위 호환성과 순회식 업그레이드가 가능하다는 결론==에 다다른다.